# 浙大《数据结构习题第二版》

## 7.1 最大子序列

### 1. 二分+归并

```c++
#include<iostream>

using namespace std;


int maxI(int a,int b,int c)
{
    return a>b?(a>c?a:c):(b>c?b:c);
}

int twoWayMerge(int a[],int head,int tail)
{
  
  
    if(head<=tail)
    {
        int mid=head+tail>>1;
        int left=twoWayMerge(a,head,mid-1);
        int right=twoWayMerge(a,mid+1,tail);
  
        int cur=0;
        int max=0;
        for(int i=mid;i<=tail;i++)
        {
            cur+=a[i];
            max=max>=cur?max:cur;
        }
        max=max>=0?max:0;
        cur=max;
        for(int i=mid-1;i>=head;i--)
        {
            cur+=a[i];
            max=max>=cur?max:cur;
        }
        max=max>=0?max:0;


        return maxI(left,right,max);
    }
    else return 0;
}


int main()
{
    int len;
    cin>>len;
    int *nums=new int[len];
    for(int i=0;i<len;i++)
    {
        cin>>nums[i];
    }
    int ans=twoWayMerge(nums,0,len-1);
    cout<<ans<<endl;
    return 0;
}
```

### 2. 动态规划

状态量：dp[i]表示以i下标为**尾部元素**的子序列的最大值，以此保证是连续的子序列。

```c++
#include<iostream>

using namespace std;


//

int main()
{
    int len;
    cin>>len;
    int *nums=new int[len];
    int *dp=new int[len+1];
    dp[0]=0;
    for(int i=0;i<len;i++)
    {
        cin>>nums[i];
    }
    int max=0;
    for(int i=0;i<len;i++)
    {
        dp[i+1]=dp[i]+nums[i]>=0?dp[i]+nums[i]:0;
        max=max<dp[i+1]?dp[i+1]:max;
    }
    cout<<max<<endl;
    return 0;
}
```

# 大数乘法

## 1.阶乘

```c++
#include<iostream>
using namespace std;
//大于12的数的阶乘   此时已经超过int数据上限
int main(){
	int num[3000]={0};		//存放大数乘法的结果
    int tmp=0;				//当前位
    int carry=0;			//进位
    int k=1;   				//标记数组num[]的数字个数  注意是从1开始，与数组下标不同
    int N;
    cin>>N;
    for(int i=2;i<=N;i++){
        for(int j=0;j<=k-1;j++){
            tmp=num[j]*i+carry;
            num[j]=tmp%10;
            carry=tmp/10;
        }
        while(carry){				//	一轮乘法结束之后还有进位，需要额外判断
            num[k]=carry%10;
            carry/=10;
            k++;
        }
    }
    for(int i=k-1;i>=0;i--){		//倒序排列，数组低位存放的是高位数字
        cout<<num[i];
    }
    return 0;
}
```

## 2.大数组相乘

```c++
#include<iostream>					//使用动态数组vector库函数来实现数据的动态输入和相乘
#include<vector>
using namespace std;

void Multi_(vector<int> &a, vector<int> &b,int Ka,int Kb) {
	//遍历数组a[]和b[]，获得最大下标Ka,Kb   数组默认倒装
    vector<int> C(Ka+Kb,0);
	int tmp = 0,  carry = 0, i = 0, j = 0, ctc = 0;
	for (i = 0; i < Ka; i++) {
		for (j = 0; j < Kb; j++) {						//注意括号内不能写int i  会覆盖外面定义的局部变量i j
			tmp = a[j] * b[i] + carry + C[j + i];
			C[i + j] = tmp% 10;
			carry = tmp / 10;
		}
		while (carry) {
			C[j + i] =(C[j+i]+carry )% 10;
			carry /= 10;
			j++;
		}
	}
	ctc = i+j-1;
	for (int k = 0; k < ctc; k++) {
		cout << C[k];
	}
}




int main() {
	int cta = 0, ctb = 0,temp=0;
	cout << "请倒序输入数字A：";
	vector<int> A;
	for (temp = 0; cin >> temp;) {
		A.push_back(temp);
		if (cin.get() == '\n') break;
	}
	cta = A.size();
	for (int i = 0; i < cta; i++)
		cout << "A[" << i << "] : " << A[i] << endl;


	cout << "请倒序输入数字B：";
	vector<int> B;
	for (temp = 0; cin >> temp;) {
		B.push_back(temp);
		if (cin.get() == '\n') break;					//使用cin动态输入数字，当输入回车（换行符）即刻终止
	}

	ctb = B.size();
	for (int i = 0; i < ctb; i++)
		cout << "B[" << i << "] : " << B[i] << endl;
	Multi_(A, B, cta, ctb);
	system("Pause");
	return 0;
}
```

## 3. 大数加法

![image-20210318200206666](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210318200206666.png)

```c++
   //按位相乘
	#include<iostream>
    using namespace std;
    #define MAX 100005
    int a[MAX + 5] = { 0 };
    int main() {
        int tmp=0,carry=0,i=0,j=0;
        int A,N;
        cin>>A>>N;
        if(N==0) cout<<0;
        for(i=N;i>0;i--){
            tmp=i*A+carry;
            a[j++]=tmp%10;
            carry=tmp/10;
        }
        while(carry){
            a[j++]=carry%10;
            carry/=10;
        }
        for(int k=j-1;k>=0;k--) cout<<a[k];
        return 0;
    }
```

# PAT习题

## 7-23 币值转换

![image-20210319143200477](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210319143200477.png)

```c++
//大体思路是使用一个动态string数组存储每四位数
//之后按字输出，每输出一个字进行判断是否输出单位“千、百、十”
#include<iostream>
#include<vector>
#include<string>
using namespace std;

int main(){
    char a[10]={'a','b','c','d','e','f','g','h','i','j'};int len=0,oplen=0,elementSize=0;
    string S;vector<string> OutPut;
    getline(cin,S);
    len=S.length();
    if(S=="0") {							//！！边界情况！！输入为零判断  不存在输入多个零的情况  
        cout<<"a";return 0;
    }
    int i=len-1;							/////////////////////////
    while(i>=0){
        string temp="";						//临时字符串，每次循环前需要重置为空
        int cnt=0;							//计数器，四个一组压入OutPut//
        while((cnt+1)%5!=0&&i>=0){
            temp.push_back(a[S[i]-'0']);	//倒序将字符串压入vector中//
            i--;cnt++;
        }
        OutPut.push_back(temp);
    }										////////////////////////
    oplen=OutPut.size();int flag=0;
    for(int i=oplen-1;i>=0;i--){							//////////////////////////////
        elementSize=OutPut[i].length();
        for(int j=elementSize-1;j>=0;j--){
            if(OutPut[i][j]=='a'&&(flag==0||flag==1)) {		//使用flag来判断是否输出零“a”
                flag=1;continue;
            }
            else if(OutPut[i][j]!='a'&&flag==1){
                flag=0;
                cout<<"a"<<OutPut[i][j];
                }
            else if(OutPut[i][j]!='a'&&flag==0)
                cout<<OutPut[i][j];
            switch(j){
                case 3:cout<<"Q";break;								//倒序输出字符串
                case 2:cout<<"B";break;
                case 1:cout<<"S";break;
                default:break;
            }
            }
        switch(i+1){
            case 2:cout<<"W";break;
            case 3:cout<<"Y";break;
            default:break;
        }
    }													////////////////////////////////////////
    return 0;
}
```

## 7-29 删除字符串中的子串

    ![image-20210320233237017](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210320233237017.png)

```c++
///////////////////基本与法实现//////////////////////////
#include<iostream>
#include<string>

using namespace std;

int main(){
    string S,tmp;
    getline(cin,S);getline(cin,tmp);
    int Slen=S.length();int Tlen=tmp.length();
    int flag=0,i,j,k,mk=0;
    while(!flag){
                    flag=1;
        for(i=0;i<Slen;i++){

            if(S[i]==tmp[0]){
                mk=1;
                for(j=i,k=0;k<Tlen;j++,k++){
                    if(S[j]!=tmp[k]) {
                        mk=0;break;
                    }
                }
                            if(mk){
                flag=0;
                for(;j<Slen;j++,i++) S[i]=S[j];
                S[i]='\0';						//交换完毕，尾部添加'\0'表示结束
                Slen=S.length();
                break;							//退出当前for循环，重新判断并且从头开始遍历
            }
            }
        }
    }
    cout<<S;
    return 0;
}



////////使用string库函数实现//////////////////
#include<iostream>
#include<string>

using namespace std;

int main(){
    string S,tmp;
    getline(cin,S);getline(cin,tmp);
    int Slen,Tlen,pos=0;
    int flag=0;
    while(!flag){
        flag=1;
        if(S.find(tmp)!=S.npos){
            flag=0;
            Slen=S.length();Tlen=tmp.length();
            pos=S.find(tmp);			
            S.erase(pos,Tlen);
        }
    }
    cout<<S;
    return 0;
}
```

# LeetCode 习题

## 一、 区间和问题：前缀和，树状数组与线段树

### 前缀和问题

#### 303.  一维数组前缀和

![image-20210422095855314](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210422095855314.png)

**数学思想：**

$$
sumRange(i,j)=
\sum_{k=i}^{j}{nums[k]}\\
=\sum_{k=0}^{j}{nums[k]}-\sum_{k=0}^{i}{nums[k]}
$$

```c++
    class NumArray {
    private:
        int* sum;
    public:

        NumArray(vector<int>& nums) {
            int len=nums.size();
            sum=new int[len+1];
            sum[0]=0;						//方便后续计算
            for(int i=1;i<len;i++){
                sum[i+1]=sum[i]+nums[i];
            }
        }

        int sumRange(int left, int right) {
            return sum[right+1]-sum[left];
        }
    };
```


#### [396.旋转数组](https://leetcode-cn.com/problems/rotate-function/)

![题目](image/算法随笔/1650598279450.png)

方法一：迭代
思路

记数组 $\textit{nums}$ 的元素之和为 $\textit{numSum}$。根据公式，可以得到：

F(0) = 0 $\times \textit{nums}[0]$ + 1 $\times \textit{nums}[1]$ + $\ldots$ + (n-1) $\times \textit{nums}[n-1]$

F(1) = 1 $\times \textit{nums}[0]$ + 2 $\times \textit{nums}[1]$ + $\ldots$ + 0 $\times \textit{nums}[n-1]$ = F(0) + $\textit{numSum}$ - n $\times \textit{nums}[n-1]$

更一般地，当 1 $\le k \lt n1≤k<n$ 时，F(k) = F(k-1) + $\textit{numSum}$ - n $\times \textit{nums}[n-k]$。我们可以不停迭代计算出不同的 F(k)，并求出最大值。

```c++
class Solution {
public:
    int maxRotateFunction(vector<int>& nums) {
        int sum = 0;
        int ans = 0;
        int size  = nums.size();
        int ptr = 0;
        int tmp_ans = 0;
        for(auto& a : nums)
        {
            sum += a;
        }

        for(int i = ptr ; i < size ; ++i)
        {
            ans += nums[i] * i;
        }
        
        ptr = (ptr+1)%size;

        tmp_ans = ans;

        while(ptr!=0)
        {
            tmp_ans = tmp_ans + sum - size * nums[size - ptr] ;
            ans = tmp_ans > ans ? tmp_ans : ans;
            ptr = (ptr+1)%size;
        }
        return ans;


    }
};
```

#### 304.  二维数组前缀和

![image-20210422101328018](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210422101328018.png)

```c++
class NumMatrix {
private:
    vector<vector<int>> sum;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int col=matrix[0].size();
        int row=matrix.size();
        sum.resize(row+1,vector<int>(col+1));        //自动全为零
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]+matrix[i][j]-sum[i][j];
            }
        }
    }
  
    int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row1][col2+1]-sum[row2+1][col1]+sum[row1][col1];		//与一维前缀和不同
    }
};
```

![image-20210422102847868](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210422102847868.png)

#### 363.  矩形区域不超过K的最大数值和

![image-20210422102932047](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210422102932047.png)

```c++
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {

    }
};
```

### 树状数组问题

**特征：** 数组内元素经常发生变化，需要不停改变前缀和的值，因此将顺序的前缀和拆分成 ==*二叉树*== 的形式，减少更改sum数组元素所需的开销。

- 定义树状数组
  ![树状数组定义](image/算法随笔/1649047527245.png)

  sum[]数组元素的下标通过lowbit(int idx)函数来确定

  ![lowbit元素](image/算法随笔/1649047584808.png)

- 更新、插入元素
    ![插入元素](image/算法随笔/1649047462036.png)

    使用lowbit累加，得到sum中的下表元素，也就是 ==**得到nums[]数组中对应的元素应该存放在sum[]数组中的什么位置**==

- 求区间和
  区间和是通过两个前缀和相减得到的值
  ![求区间和](image/算法随笔/1649047659180.png)

#### 307. 区域和检索 - 数组可修改



## 二、 最长递增子序列

### 300.最长递增子序列

```c++
//动态规划可解
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return 1;
        vector<int> f(n,0);
        for(int i=0;i<n;i++){
            int len=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    if(f[j]+1>len){
                        len=f[j]+1;

                    }
                }
            }
            f[i]=len;
        }
    
        int index=max_element(f.begin(),f.end())-f.begin();
        return f[index];
    }
};
```

### 368.  最大整除子集

![image-20210423115358179](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210423115358179.png)

```c++
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int len=nums.size();
        if(len==0||len==1) return nums;
        vector<int> f(len,0);			//动态规划数组，f[i]表示以nums[i]为结束的最长整除子序列
        vector<int> g(len,0);			//回溯数组，用于输出序列
        sort(nums.begin(),nums.end());
        for(int i=0;i<len;i++){
            int lth=1;int prev=i;
            for(int j=0;j<i;j++){
                if(nums[i]%nums[j]==0){
                    if(f[j]+1>lth){
                        lth=f[j]+1;
                        prev=j;
                    }
                }
            }
            f[i]=lth;
            g[i]=prev;
        }


        int index=max_element(f.begin(),f.end())-f.begin();
        int max=f[index];

        vector<int> op;
        while(op.size()<max){
            op.push_back(nums[index]);
            index=g[index];
        }

        return op;
    }
};
```

## 三、 图的遍历算法（DFS、BFS）

### [417.大西洋太平洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

**特征**：使用 **==逆向==深度优先搜索**，从图的边界开始向内部搜索。$visit1[]$和$visit2[]$用来记录**从两个海岸线开始遍历**的已遍历过的节点。

```C++
class Solution {
private:
    int row;
    int col;
    int direction[5] = {-1,0,1,0,-1};
    vector<vector<int>> ans;
    void dfs(vector<vector<int>>& heights, vector<vector<int>>& mark, vector<vector<bool>>& visit, int row, int col)
    {
        if(visit[row][col] != false || row >= heights.size() || row < 0 || col >= heights[0].size() || col < 0)
        {
            return;
        }
        else
        {
            visit[row][col] = true;
            ++mark[row][col];
            for(int i = 0 ; i < 4 ; ++i)
            {
                if(row+direction[i] >= heights.size() || row+direction[i] < 0 || col+direction[i+1] >= heights[0].size() || col+direction[i+1] < 0) continue;
                if(heights[row][col] <= heights[row+direction[i]][col+direction[i+1]])
                {
                    dfs(heights,mark,visit,row+direction[i],col+direction[i+1]);
                }
                
            }
            return;
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        row = heights.size();
        col = heights[0].size();
        vector<vector<int>> mark(row,vector<int>(col,0));
        vector<vector<bool>> visit1(row,vector<bool>(col,false));
        vector<vector<bool>> visit2(row,vector<bool>(col,false));
        for(int i = 0 ; i < row ; ++i)
        {
            if(visit1[i][0] == false)
            {
                dfs(heights,mark,visit1,i,0);
            }
            if(visit2[i][col-1] == false)
            {
                dfs(heights,mark,visit2,i,col-1);
            }
        }
        for(int i = 0 ; i < col ; ++i)
        {
            if(visit1[0][i] == false)
            {
                dfs(heights,mark,visit1,0,i);
            }
            if(visit2[row-1][i] == false)
            {
                dfs(heights,mark,visit2,row-1,i);
            }
        }

        vector<int> tmp;
        for(int i = 0 ; i < row ; ++i)
        {
            for(int j = 0 ; j < col ; ++j)
            {
                if(mark[i][j] > 1)
                {
                    tmp.push_back(i);
                    tmp.push_back(j);
                    ans.push_back(tmp);
                    tmp.clear();
                }
            }
        }
        return ans;
    }
};
```

### [725. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

```c++
class Solution {
private:
    unordered_set<string> deadNums;     //哈希表记录死亡数字
  
    unordered_set<string> seen;         //哈希表记录已经访问的数字避免重复访问

    queue<pair<string, int>> rcrd;

    char num_prev(char& a)
    {
        return a=='0'?'9':a-1;
    }

    char num_succ(char& a)
    {
        return a=='9'?'0':a+1;
    }

    vector<string> get(string init)
    {
        vector<string> ret;
        for(int i=0;i<4;++i)
        {
            char tmp=init[i];
            init[i]=num_prev(tmp);
            ret.push_back(init);
            init[i]=num_succ(tmp);
            ret.push_back(init);
            init[i]=tmp;
        }
        return ret;

    }

  

public:
    int openLock(vector<string>& deadends, string target) {
        deadNums.clear();
        seen.clear();
        seen.insert("0000");
        rcrd.emplace("0000",0);


        if(target=="0000") return 0;
        for(auto& str : deadends)
        {
            deadNums.insert(str);
        }
        if(deadNums.count("0000")) return -1;

        while(!rcrd.empty())
        {
            auto [tar, step] = rcrd.front();
            rcrd.pop();
            for(auto next_status : get(tar))
            {
                if(!seen.count(next_status)&&!deadNums.count(next_status))
                {
                    if(next_status==target)
                    {
                        return step+1;
                    }
                    rcrd.emplace(next_status, step+1);
                    seen.insert(move(next_status));
                }
            }
        }
        return -1;

    }
};
```

###  [127.单词接龙](https://leetcode-cn.com/problems/word-ladder/)


**单项BFS遍历**
```c++
class Solution {
private:
    unordered_set<string> dict;     //Hash字典，方便快速查找wordList中的单词
    int ans;                        //层数，也是返回值
    int size;                       //单词长度
    bool mark = false;              //标志位
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        //将wordList中的单词加入Hash字典
        for(const auto & tar :wordList)
        {
            dict.insert(tar);
        }

        //先手判断是否能完成变换
        if(dict.count(endWord) == 0) return 0;


        size = beginWord.size();

        //建立队列存放当前bfs遍历层数
        queue<string> q;
        q.push(beginWord);

        //预处理
        //1. 将层数设置为0
        ans = 0;
        //2. 防止重复遍历，将已经遍历过的单词从dict中抹除
        dict.erase(beginWord);

        //开始遍历
        while(!q.empty())
        {
            ans++;                              //当前遍历的单词已经处于下一层的位置，所以层数ans直接+1
            
            //统计当前层的单词总数，一次遍历一层的全部节点
            int q_size = q.size();              
            for(int k = 0 ; k < q_size ; ++k)
            {
                const string curWord = q.front();   //当前节点，也是父节点
                q.pop();
                string neWord = curWord;            //下一层节点，也是子节点

                //按位替换单词中的字母
                for(int i = 0 ; i < size ; ++i)
                {
                    const char ptr = neWord[i];     //保存当前替换位的字母
                    for(char c = 'a' ; c <= 'z' ; ++c)
                    {
                        neWord[i] = c;              //替换之后形成新的单词
                        if(dict.count(neWord) == 0) continue;

                        //cout << neWord <<endl;
                        //cout << ans <<endl;

                        //到这一步时，neWord必然在dict字典中，进行进一步处理
                        //1. 从字典中抹除neWord
                        dict.erase(neWord);

                        //2. 如果neWor就是endWord则设置标志位为true
                        if(neWord == endWord) mark = true;

                        //3. 将neWord加入队列q，作为下一层遍历的对象
                        q.push(neWord);
                    }
                    neWord[i] = ptr;
                }
            }
            
            if(mark) break;
        }
        //判断结果
        if(mark) return ans + 1;
        else return 0;
    }
};
```

**双向BFS的遍历**

```c++
class Solution {
private:
    unordered_map<string,int> left;     //beginWord对应当前的层数
    queue<string> lq;

    unordered_map<string,int> right;    //endWord对应当前的层数
    queue<string> rq;
  
    unordered_set<string> wrdl;         //Hash字典存储wordList方便快速查找判断

    int len = beginWord.length();       //字母长度

    int update(queue<string>& q, unordered_map<string,int>& cur, unordered_map<string,int>& other)
    {
        string ptr = q.front();
        
        q.pop();

        for(int i = 0 ; i < len ; ++i)
        {
            string tmp = ptr;
            for(int j = 0 ; j < 26 ; ++j)
            {
                tmp[i] = 'a' + j ;
                if(wrdl.count(tmp))
                {
                    //当前方向已经遍历到该节点，直接跳过
                    if(cur.count(tmp)) continue;
                    
                    //另一方向中存在当前单词，则表明遍历结束，已经获得结果
                    if(other.count(tmp)) 
                    {
                        return other[tmp]+cur[ptr]+1;
                    }
                    else
                    {
                        //将当前单词入队
                        q.emplace(tmp);
                        //更新当前遍历方向的单词所在层数
                        cur[tmp]=cur[ptr]+1;
                    }
                }
            }
        }
        return -1;
    
    }



    int bfs()
    {
        while(!lq.empty()&&!rq.empty())
        {
            int mk=-1;
            if(lq.size()>rq.size())
            {
                mk=update(rq,right,left);
            }
            else
            {
                mk=update(lq,left,right);
            }
            if(mk!=-1) return mk;
        }
        return -1;
    }



public:
    int ladderLength(string bW, string eW, vector<string>& wordList) {
        left.clear();
        right.clear();
        wrdl.clear();
        for(auto& str : wordList)
        {
            wrdl.insert(str);
        }
        if(!wrdl.count(eW)) return 0;



        lq.emplace(bW);
        rq.emplace(eW);
        left[bW]=0;
        right[eW]=0;

        int ans=bfs();

    
        return ans==-1?0:ans+1;

    
    }
};
```

### [126. 单词接龙II](https://leetcode-cn.com/problems/word-ladder-ii/)

**特征：使用bfs遍历得到最短距离，使用dfs获得路径**

```c++
class Solution {
private:
    unordered_set<string> dict; //存储wordList,以便快速查找单词表
    unordered_map<string,int> lvl_map;  //存储每个单词对应的层数
    unordered_map<string,unordered_set<string>> drv_map ;   //key:目标单词 vec:单词列表，其中存储的单词可以变化为key也就是key's parents 
                                                            //反向记录路径  
    vector<vector<string>> ans; //返回值
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        //单词表加入Hash表中
        for(const auto & tar : wordList)
        {
            dict.insert(tar);
        }
        //若endWord不在单词表中则直接返回空值
        if(dict.count(endWord)==0) return ans;
        //为了防止重复遍历，每次将当前遍历到的单词从dict中抹除
        dict.erase(beginWord);

        //STEP 1:记录每个单词的当前遍历层数
        lvl_map[beginWord] = 0;

        int wordSize = beginWord.size();

        int lvl = 0;
        bool found = false;

        queue<string> q ;
        q.push(beginWord);
        while(!q.empty())
        {
            lvl++;
            int cur_lvl_size = q.size();
            for(int i = 0 ; i < cur_lvl_size ; ++i)
            {
                string curWord = q.front();
                string neWord = curWord;
                q.pop();
                
                for(int j = 0 ; j < wordSize ; ++j)
                {
                    const char ptr = neWord[j];
                    for(char c = 'a' ; c <= 'z' ; ++c)
                    {
                        neWord[j] = c;


                        //不同cur父单词通过字母变换得到相同的一个ne子单词
                        //因为在首次遍历到ne之后就将其从dict中移除，而仍然有其他的父单词cur可以通过变换得到ne子单词。
                        if(lvl_map[neWord] == lvl)
                        {
                            drv_map[neWord].insert(curWord);
                            //curWord不同情况下得到相同的ne
                        }


                        if(dict.count(neWord)==0)
                        {
                            continue;
                        }
                        //neWord存在于dict字典中，可以进行进一步处理
                        //去重，避免重复遍历
                        dict.erase(neWord);
                        //当前层入队
                        q.push(neWord);
                        //记录ne与cur的关系：ne子cur父
                        drv_map[neWord].insert(curWord);
                        //记录ne的lvl层数
                        lvl_map[neWord] = lvl;
                        //入队，记录完毕之后  判断ne是否已到末尾
                        if(neWord == endWord)
                        {
                            found = true;
                        }
                    }
                    //恢复原值
                    neWord[j] = ptr;
                }
            }
            //为什么在最外围break？
            //等待一轮bfs完全结束后才能得到最短距离
            if(found) break;
        }
        if(found)
        {
            vector<string> Path = {endWord};
            dfs(ans , endWord , drv_map , Path);
        }
        return ans;
    }

    void dfs(vector<vector<string>> &res, const string &Node, unordered_map<string, unordered_set<string>> &from, vector<string> &path)
    {
        if(from[Node].empty())
        {
            res.push_back({path.rbegin(),path.rend()});
            return;
        }
        else
        {
            for(const string& parent : from[Node])
            {
                path.push_back(parent);
                dfs(res,parent,drv_map,path);
                path.pop_back();
            }
        }
    }
};
```

### 403. 青蛙过河

**经典的错误**：记录重复的数据需要和queue中的数据构成一致

本体中判重的根据是**位置**和**跳到该位置的步数**

```c++
bool seen[2042][2042];        //下标，步数
class Solution {
private:
    queue<pair<int,int>> q;         //下标，步数
    unordered_map<int,int> se;      //位置
    bool bfs(vector<int> stones,int end)
    {
        q.emplace(make_pair(stones[0],0));
        seen[stones[0]][0]=true;
        while(!q.empty())
        {
            auto P = q.front();
            q.pop();
            int step = P.second;
            int idx = P.first;

            if (idx == end)
                return true;
            for(int i =-1;i<=1;i++)
            {
                int next_st = step+i;
                int next_pos = next_st + stones[idx];
                if(next_st<=0) continue;
                if(se.count(next_pos))
                {
                    int next_idx = se[next_pos];
                    if(next_idx==end) return true;
                    if(!seen[next_idx][next_st])
                    {
                        seen[next_idx][next_st]=true;
                        q.emplace(make_pair(next_idx,next_st));
                    }
                }
            }

        }
        return false;
    }


public:
    bool canCross(vector<int>& stones) {
        se.clear();
        memset(seen,0,sizeof(seen));
        int len = stones.size();
        for(int i = 0;i<len;i++)
        {
            se[stones[i]]=i;
        }
        int end = len-1;
        bool ans = bfs(stones,end);
        return ans;
    }
};
```

### 815. 公交路线

```c++
class Solution {
private:
    unordered_map <int,int> tarvisited;          //路线，步数
    queue<int> tarq;                                //路线

    unordered_map<int,unordered_set<int>> mk;    //位置，路线


public:
    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {
        int bus = routes.size();
        if(source==target) return 0;
        for(int i =0 ;  i<bus;++i)
        {
            for(auto tar : routes[i])
            {
                mk[tar].insert(i);
                if(tar==target)
                {
                    tarq.emplace(i);
                    tarvisited[i]=1;
                }
            }
        }
        while(!tarq.empty())
        {
            auto stat = tarq.front();
            tarq.pop();
            for(auto next_pos : routes[stat])
            {
                if(next_pos==source) return tarvisited[stat];
                for(auto next_stat : mk[next_pos])
                {
                    if(!tarvisited[next_stat])
                    {
                        tarq.emplace(next_stat);
                        tarvisited[next_stat]=tarvisited[stat]+1;
                    }
                }
            }
        }
        return -1;
    }
};
```

## 四、 单调栈

### 特点

1. 要求保持原来数据的**相对位置**;
2. 要求数据按照**非递增、非递减**等一定顺序排列

### [单调栈军训题](https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/)


### [84.柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```c++
class Solution {
private:
    stack<int> wader;
    int ans = 0;
public:
    int largestRectangleArea(vector<int>& heights) {
        int len = heights.size();

        int left[len];
        for(int i = 0 ; i < len ; ++i)
        {
            left[i]=-1;
        }
        int right[len];
        for(int i = 0 ; i < len ; ++i)
        {
            right[i]=len-1;
        }
        //初始化


        wader.push(0);
        for(int i = 1 ; i < len ; ++i)
        {
            while(!wader.empty() && heights[i] < heights[wader.top()])
            {
                right[wader.top()] = i - 1;
                wader.pop();
            }
            left[i] = wader.empty()?-1:wader.top();
            wader.push(i);
        }

        for(int i = 0 ; i < len ; ++i)
        {
            ans = max(heights[i]*(right[i]-left[i]),ans);
        }
        return ans;
    }
};
```

### [316.去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

```c++
class Solution {
private:
    string ans;
    bool mark[128] = {false};       //是否访问
    int cnt[128] = {0};             //该字符是否为字符串中最后出现的字符
public:
    string removeDuplicateLetters(string s) {
        ans = "";
        if(s.size() == 1) return s;

        for(const auto& c : s)
        {
            cnt[c]++;
        }

        for(const auto& c : s)
        {
            //未访问过，可以将该字符加入单调栈
            if(!mark[c])    
            {
                //将栈顶元素与当前遍历到的字符比较，若字典序比当前字符大则进行进一步处理
                while(!ans.empty() && ans.back() > c)
                {
                    //如果栈顶元素并非该字符串s中所有相同字符中的最后一个，则可以弹出
                    if(cnt[ans.back()] > 0 )
                    {
                        //相应地，对应栈顶元素的访问标记置为false
                        mark[ans.back()] = 0;
                        ans.pop_back();
                    }
                    else
                        break;
                }
                mark[c] = true;
                ans.push_back(c);
            }

            //不要加else，无论是否遍历过都应该将计数-1，以此保证是单向选取元素（也就是不会回退）
            //已经遍历过了，只需要直接将计数-1
            cnt[c]--;
        }
        return ans;
    }
};
```

### [402.移除k位数字](https://leetcode-cn.com/problems/remove-k-digits/)

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        string ans = "";
        if(k == num.size()) return "0";
        for(const char& c : num)
        {
            while(!ans.empty() && ans.back() > c && k)
            {
                ans.pop_back();
                k--;
            }
            ans.push_back(c);
        }
        int size = ans.size();
        if(k && k <= size)      //若需要移除的数个数k仍然存在，则直接抹除后面几位数字
        {
            ans.erase(size - k , k);
        }
        while(!ans.empty() && ans[0] == '0')
        {
            ans.erase(0,1);
        }
        if(ans.empty()) ans.push_back('0');

        return ans;
    }
};
```

## 五、 桶排序

### 220. 存在重复元素III

一般思路：用**有序集合**set保存**滑动窗口**内的数据，每次遍历到新的数则从set中取出**离下标$cur-t$最近的值**进行比较，如果该值处于$[cur-t,cur+t]$之间则返回true，若没有则将本次遍历到的数值加入set。

**如何保持滑动窗口**：如果$i-k>=0$，则set中存在**滑动窗口以外**的元素（也就是包括$nums[i-k]$之后的元素），需要erase。

```c++
#define LL long long
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        set<LL> srch;
        int n = nums.size();
        LL dec = t*1LL;
        for(int i = 0 ; i < n ; ++i)
        {
            LL cur = nums[i]*1LL;
            auto it = srch.lower_bound(cur-dec);
            if(it!=srch.end()&&abs((*it)-cur)<=dec) return 1;
            srch.insert(cur);
            if(i>=k)
            {
                LL del = nums[i-k]*1LL;
                srch.erase(del);
            }
        }
        return false;
    }
};
```

**桶排序**：

桶的下标getInd()表明**处于同一区间内的元素**：

- 如果在一个桶内则一定满足$|nums[i]-nums[j]|<=t$
- 如果桶不存在，则对相邻的桶的内部元素进行比较，查看是否满足要求
- 都没有满足，则新建立本次遍历元素对应的桶
- 去重

**如何进行桶的划分**：

- 自然数：相差t的元素，在**数轴上相距t+1**，因此将元素对t+1取商后的值作为桶的下标
- 负数：元素值+1后对t+1取商，结果再-1，表示整体在数轴上左移一位

```c++
#define LL long long
class Solution {
public:
    LL getInd(LL& tar,LL& t)
    {
        //此处为桶排序的重点：如何针对正负元素值进行桶下标的划分。
        return tar>=0?(tar/(t+1)):((tar+1)/(t+1))-1;
    }
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        unordered_map<LL,LL> serch_bre;
        serch_bre.clear();
        int n = nums.size();
        LL val_t = t * 1LL;
        for(int i = 0 ; i < n ; ++i)
        {
            LL tar = nums[i] * 1LL;
            LL breNum = getInd(tar , val_t);
            //
            if(serch_bre.count(breNum)) return true;

            if(serch_bre.count(breNum-1)&&abs(serch_bre[breNum-1]-tar)<=val_t) return true;
            if(serch_bre.count(breNum+1)&&abs(serch_bre[breNum+1]-tar)<=val_t) return true;

            serch_bre.insert({breNum , tar});

            if(i>=k)
            {
                LL cur = nums[i-k]*1LL;
                int del = getInd(cur , val_t);
                serch_bre.erase(del);
            }
        }
        return false;
    }
};
```

## 六、 巧用哈希表

### 1711. 大餐计数

- 用线性时间遍历数组-->哈希表
- 用固定的时间代价寻找哈希表中与当前遍历到的元素的和属于2^n的元素个数

  数组最大值max，则两数之和不可能超过2*max，因此在$[1,2max]$区间内**枚举**2的幂次，并在哈希表中寻找另一半$tar-cur$。

```c++
#define LL long long
#define root 1000000007
class Solution {
private:
    unordered_map<int,int> ret;
public:
    int countPairs(vector<int>& de) {
        ret.clear();
        int len = de.size();
        int imax = 0;
        int pair = 0;
        for(int i = 0 ; i < len ; ++i)
        {
             imax = max(imax,de[i]);  
        }
        imax*=2;
        for(int i = 0 ; i < len ; ++i)
        {
            for(int tar = 1 ; tar <= imax ; tar<<=1)
            {
                int cur = 0;
                if(ret.count(tar-de[i])) 
                {
                    cur = ret[tar-de[i]];
                }
                else cur = 0;
                pair = (pair + cur)%root;
            }
            ret[de[i]]++;
        }
        return pair;
    }
};
```

**TIPS**

- 科学记数法定义出来的变量默认是double类型，而int和double无法做乘除运算。

## 七、 双指针

适用于处理**顺序数组**的情况。

### 713. 乘积小于K的连续子数组

统计所有子序列的个数，用累加法

```c++

class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if(k==0) return 0;
        int len = nums.size();
        int left = 0 , right = 0 , mq = 1;
        int cnt = 0;
        while(right<len)
        {
            while(right<len&&nums[right]>=k)        //1. 判断跳过无效的子数组
            {
                right++;
                left = right;
            }
    
            while(right<len&&mq*nums[right]<k)
            {
                mq*=nums[right];
                right++;
            }
            cnt+=(right-left)*(right-left+1)/2;
            if(right<len)
            {
                int cur = mq*nums[right];
                while(cur >= k && left < right)
                {
                    cur/=nums[left];
                    mq/=nums[left];
                    ++left;
                }
                cnt-=(right-left)*(right-left+1)/2;
            }
        }   
        return cnt;
    }
};
```

### 15. 三数之和

### 16. 最近的三数之和

### 20. 四数之和

**注意---->** 指针遍历时左右指针同时向中间靠拢，当遍历到合适的结果时**不要直接break** ，必须将当前顺序序列全部遍历完成。

## 八、 常数空间层次遍历

### 117. 填充每个节点的下一个节点

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    void init_next(Node* &prev , Node* &cur , Node* &nextLVL)       //注意：传入指针需要加引用&改变指针的值
    {
        if(prev)        //前一指针
        {
            prev->next = cur;
        }
        if(!nextLVL)    //本层最左边第一个节点
        {
            nextLVL = cur;
        }
        prev = cur;
    }
    Node* connect(Node* root) {
        if(!root) return nullptr;
        Node* cur = root;

        while(cur)
        {
            Node* prev = nullptr, * next = nullptr;
            for(Node* p = cur ; p != nullptr ; p = p->next)
            {
                if(p->left)
                {
                    init_next(prev,p->left,next);
                }
                if(p->right)
                {
                    init_next(prev,p->right,next);
                }
            }
            cur = next;
        }
        return root;
    }
};
```

## 九、位运算专题

### 算法

1. x&1
   每次将数值与1按位求解，得到当前x的最低位的值。
   ```c++
   while(x)
   {
       if(x&1) cnt++;
       x>>=1;
   }
   ```
   时间复杂度o(k)，k为数值x的位数

2. lowbit函数法
   `lowbit(int x)` 可以求得数据x位数中**最低位的1所在的位置**
   ```c++
   for(int i = x ; i > 0 ; i -= lowbit(i))      //i=0时lowbit无意义
   {
       cnt++;
   }


   // lowbit函数定义
   int lowbit(int x)
   {
       return x&-x;
   }
   ```
   该方法可以用于**树状数组**

3. 分治法
   处理超长位数的数据有奇效，时间复杂度为o($ log(logx) $)
   ```c++
    int hammingWeight(unsigned int n) {
        n = (n & 0x55555555) + ((n >> 1)  & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2)  & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >> 4)  & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >> 8)  & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
        return n;
    }
   ```

### 实例

#### [判断字符串中出现的字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

小写字符总共有26个，而一个整型变除去符号位以外共有31位。可以使用一个4Byte的整型变量来标记26个字符的情况。也就是**微型哈希表**。

```c++
class Solution {
public:
    bool isUnique(string astr) {
        int mark = 0;
        for(auto& tar : astr)
        {
            if(mark & (1 << (tar - 'a'))) return false;
            mark |= (1 << (tar - 'a'));
        }
        return true;
    }
};
```

## 十、 贪心算法

### 特征

通过局部最优解简单相加得到最终结果，一般用于求解**最值问题**

大多数问题在求解之前需要对既定数据进行**预处理**，比如排序。

### 分配问题

#### [135.Candy(Hard)](https://leetcode-cn.com/problems/candy/)

固定位置的贪心算法，进行从右到左和从左到右两轮遍历即可。

### 区间问题

解决 ==**区间合并**== 与 ==**区间独立**== 的问题

会使用到**回调函数**，c++中回调函数写法如下：
```c++
sort(a.begin(),b.end(), [](vector<int>& a , vector<int>& b){
    //函数实现
    return ...;
});
```
   

## 十一、 二分查找算法

### 特征

一般是在一个**有序数组**中查找元素

对于非有序数组，也可以使用二分查找，前提是必须满足**数组内的数据如果不满足条件A，则在分界点的一侧；满足A则在另一侧**这种形式

### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

![540](image/算法随笔/1649403033721.png)

**数组特征** ： 
 - 只出现一次的那个数**不在中间点左边就在中间点右边**
 - 对于目标元素出现之前的数组序列中，元素与其下标之间满足的关系为`nums[idx]==nums[idx^1]`, 设为==条件A==。
 - 满足条件A-->在中间点右边查找；不满足条件A-->在中间点左边查找


### [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

![81](image/算法随笔/1649409026972.png)

**数据去重**：一开始首末两端的数据会出现相同的情况，这时只需要将右端点元素往左移一位即可。

**条件A**：`nums[mid] <= nums[right]`表明右段数据非递减有序；反之则左段数据非递减有序。**在此基础上**将$target$与$nums[mid]$和$nums[right]$比较即可得到下一步查找的数据段范围。


## 十二、 背包问题


### 0-1背包问题

#### 物品只有**一个维度**的重量属性

[416.分割子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

物品的**重量**即为数组中的每个数值，而**价值**则为==是否能够平均分配==这样一个状态属性。

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int target = 0;
        for(auto& tar : nums)
        {
            target += tar;
        }

        //无法平均分成两份则必为false
        if(target % 2) return false;

        //0-1背包问题
        target /= 2;
        vector<bool> dp(target + 1 , false);
        dp[0] = true;

        for(int i = 1 ; i <= nums.size() ; ++i)
        {
            int w = nums[i-1];
            for(int j = target ; j >= w ; --j)
            {
                dp[j] = dp[j-w] || dp[j];
            }
        }
        return dp[target];
    }
};
```

#### 物品包含**多个维度**的重量属性

 [474.一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

物品的**重量**属性拥有多个，属于多维度01背包问题。这一题中物品的重量对应为**每个字符串中包含的0和1字符的个数**，因此最简形式的 **==空间复杂度==** 为二维矩阵（从三维矩阵压缩而来）。

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(string cur : strs)
        {
            //统计当前}“物品”的两个维度的“重量”，也就是0和1的个数
            int zeroCnt = 0, oneCnt = 0;
            for(char tmp : cur)
            {
                if(tmp=='1') oneCnt++;
                else zeroCnt++;
            }

            //三维空间复杂度压缩至二维空间复杂度下的逆向遍历求解
            for(int i = m ; i >= zeroCnt ; --i)
            {
                for(int j = n ; j >= oneCnt ; --j)
                {
                    dp[i][j] = dp[i-zeroCnt][j-oneCnt] + 1 > dp[i][j] ? dp[i-zeroCnt][j-oneCnt] + 1:dp[i][j];
                }
            }
        }
        return dp[m][n];
    }
};
```

## 十三  蓄水池抽样算法

大数据工程师

### 适用场景

数据量 ==N== 很大（远超内存空间），需要**一次遍历**（时间复杂度o(N)）之后直接得到 ==k== 个随机抽取的数据。