
# 数据结构

## 第二章  线性表

### 顺序存储结构线性表的插入删除操作

```c++
#define MAXSIZE 114514

typedef struct LNode{
    int data[MAXSIZE];
    int Last;
}LNode,*SeqList;

bool Insertion(SeqList L,int X,int pos){		//数组下标从0开始，Last为存放的数组下标最大数（从0开始），pos从1开始
    if(pos<1||pos>MAXSIZE+1) return false;		//插入位置判断
    if(L->Last==MAXSIZE-1) return false;		//溢出判断
    for(int i=L->Last;i>=pos-1;i--){
        L->data[i+1]=L->data[i];				//从后往前     a[i]-->a[i+1]
    }
    L->data[pos-1]=X;
    L->Last++;									//长度+1
    return true;
}

bool Deletion(SeqList &L,int pos){
    if(pos<1||pos>L->Last+1) return false;
    if(!L) return false;
    for(int i=pos-1;i<L->Last){
        L->data[i]=L->data[i+1];				//从P点往后 到倒数第二个位置
    }
    L->Last--;
    return true;
}
```

### 单链表的初始化、插入、删除、就地倒置操作

```c++
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

LNode *  Insertion(LinkList L,int X,int pos){
    LNode *p=new LinkList;LNode *head=L;
    p->data=X;
    p->next=NULL;
    int count=1;
    if(pos==count){						//无头结点，单独判断
        p->next=L;
        return p;
    }
    if(pos<1) return L;
    while(L){
        if(count==pos-1){
            p->next=L->next;
            L->next=p;
            return head;
        }
        L=L->next;
        count++;
    }
    return ERROR;
}

LNode * Deletion(LinkList L,int pos){
    LNode * head=L;
    int count=1;
    if(pos<1) return L;
    if(pos==count){						//无头结点，单独判断
        L=L->next;
        return L;
    }
    while(L){
        if(count==pos-1){
            L->next=L->next->next;
            return head;
        }
        count++;
        L=L->next;
    }
    return ERROR;
}




LNode * Reverse(LinkList L){
    LNode *head=L;						//无头结点
    LNode *s=L->next;
    head->next=NULL;
    while(s){
        LNode *p=s->next;
        s->next=head;head=s;s=p;
    }
    return head;						//经过一轮变换，头指针已经指向原链表的最后一个结点
}




LNode * Split(LinkList &L){				//只讨论带头结点的情况
    LNode *A=new LinkList;A->next=NULL;
    LNode *p=L->next;
    LNode *head=A;
    L->next=NULL;
    while(p){
        LNode *s=p->next;
        p->next=L->next;L->next=p;
        p=s;
        A->next=p;A=A->next;
    }
}
```





## 第三章  栈与队列

栈和队列都是**存取受限的**线性结构，栈是先进后出，队列是先进先出。

###  栈

#### 1. 栈的顺序存储结构

```c++
//栈的结构
#define MAX 114514
typedef struct {
    int data[MAX];
    int top; 			//栈顶指针
}SqStack;


//栈的初始化
void InitStack(SqStack &S){
    S.top=-1;					//栈顶指针指向栈顶元素
    //S.top=0;		栈顶指针指向栈顶元素的上一个元素
}

//入栈
bool Push(SqStack &S,int x){
    if(S.top==MAX-1) return false;	//判断满栈StackOverflow(S)
    S.data[++S.top]=x;
    return true;
}

//出栈
bool Pop(SqStack &S,int &x){
    if(S.top==-1) return false;
    x=S.data[S.top--];
    return true;
}
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//共享栈
#define MAX 114514
typedef struct{
    int data[MAX];
    int top[2];   			//0表示左边的栈   1表示右边的栈
}SSS;

//初始化
void InitSSS(SSS &S){
    S.top[0]=-1;
    S.top[1]=MAX;
}

//入栈
bool PushSSS(SSS &S,int flag,int x){
    if(flag<0||flag>1) return false;
    if(S.top[1]-S.top[0]==1) return false;
    else if(flag==0){
        S.data[++S.top[0]]=x;
        return true;
    }
    else{
        S.data[--S.top[1]]=x;
        return true;
    }
}
```

#### 2. 栈的链式结构

栈带不带头结点由题干条件给出

```c++
typedef struct LinkNode{
    int data;
    LinkNode *next;
}LkStack*;			//所有操作都在链首进行，只要一个链首头指针即可

//入队出队均在链表表头进行
```

#### 3. 栈的巧妙用法

使用栈来完成 **回文字** 的判定

用单链表L存储字符，构造一个函数判断是否为回文字，是返回1，否返回0

单链表默认无头结点

```c++
bool ReverseW(LinkList L,int len){
    if(L==NULL) return false;
    if(len==1) return true;
    char S[n/2]={'0'};
    int i=0;
    for(i=0;i<n/2;i++){
        S[i]=L->data;
        L=L->next;
    }
    i--
    if(len%2==1){L=L->next};
    while(i&&L){
        if(S[i]==L->data) {i--;L=L->next;}
        else return false;
    }
    return true;
}
```

### 队列

#### 1.  队列的顺序存储结构

默认队列是带头结点的

```c++
//循环队列，使用取模操作完成  %
//Plan A:牺牲一个存储单元，用于表示队列是否已满
//基本结构体
#define MAX 114514
typedef struct{
    int data[MAX];
    int front,rear;
}Queue;


//循环队列初始化
void InitQueue(Queue &Q){
    Q.rear=Q.front=0;		//此种表示方法为front指向队头元素，rear指向队尾元素的后一个元素，即空位置处
    						//若rear直接指向的是队尾元素，则rear初始化为MAX-1
}

//入队
bool EnQueue(Queue &Q,int x){
    if((Q.rear+1)%MAX==Q.front) return false;		//队列满
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MAX;							//不能Q.rear++%MAX
    return true;
}

//出队
bool DeQueue(Queue &Q,int &x){
    if((Q.rear==Q.front)) return false;				//队列空
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MAX;
    return true;
}
//////////////////////////////////////////////////
//Plan B:使用tag标记，若tag=0时是出队导致的Q.rear=Q.front则队空；若tag=1时是入队导致的Q.rear=Q.front则队满
typedef struct{
    int data[MAX];
    int front,rear,tag;
}TQueue;

//入队
bool EnTQueue(TQueue &Q,int x){
    tag=1;
    if(tag==1&&Q.front==Q.rear) return false;		//队满
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MAX;
    return true;
}

//出队
bool DeTQueue(TQueue &Q,int &x){
    tag=0;
    if(tag==0&&Q.front==Q.rear) return false;		//队空
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MAX;
    return true;
}
```

#### 2.  队列的链式结构

```c++
typedef struct LinkNode{
    int data;
	LinkNode *next;
}LinkNode;

typedef struct {
    LinkNode *front,*rear;		//单链表的头指针和尾指针，头指针指向头结点，尾指针指向最后一个元素节点，注意此处与顺序队列的区别
}LkQueue;
//一般将链式队列设计成有头结点的单链表，这样在队头的插入删除操作就统一了	而循环单链表则适合不释放空闲节点的循环队列

//初始化
void InitQueue(LkQueue &Q){
    Q.front=Q.rear=new LinkNode;
    Q.front->next=NULL;
}

//出队
bool DeQueue(LkQueue &Q,int &x){
    if(Q.front==Q.rear) return false;
    LinkNode *s=Q.front->next;
    x=s->data;
    Q.front->next=s->next;
    if(Q.rear==s) {Q.rear=Q.front;}		//与链栈不同，出队时如果是最后一个元素，要更改
    free(s);
    return true;
}
```

#### 3.  队列的巧妙用法

用**双栈**来实现入队、出队操作

1号栈入队，2号栈出队，则入队时有一下几种情况：

​	1）1号栈没满————正常入队

​	2）1号栈满且2号栈非空（有元素在里面，此时是入队操作，无法出队）————队满

​	3）1号栈满且2号栈空（此时可以进行元素的转移）————S1--->S2直到S1空，再把要入队的元素压入S1栈中

出队也有三种情况：

​	1）2号栈非空————正常出队

​	2）2号栈空且1号栈也空————队空

​	3）2号栈空且1号栈非空————S1--->S2 直到S1空，再把S2中的元素出栈

```c++
//入队
bool EnQueue(Stack &S1,Stack &S2,int x){
    if(!StackOverflow(S1)){
        Push(S1,x);
        return true;
    }
    else if(StackOverflow(S1)&&!StackEmpty(S2)){return false;}		//队满
    else if(StackOverflow(S1)&&StackEmpty(S2)){
        int tmp;
        while(!StackEmpty(S1)){
            Pop(S1,tmp);
            Push(S2,tmp);
        }
        Push(S1,x);
        return true;
    }
}

//出队
bool DeQueue(Stack &S1,Stack &S2,int &x){
    if(!StackEmpty(S2)){
        Pop(S2,x);
        return true;
    }
    else if(StackEmpty(S1)) return false;					//队空
    else if(StackEmpty(S2)&&!StackEmpty(S1)){
        while(!StackEmpty(S1)){
            Pop(S1,x);
            Push(S2,x);
        }
        Pop(S2,x);
        return true;
    }
}
```



带头尾结点的**循环单链表**在队列中的应用

一般来说循环单链表对队列结构有点冗余，其尾结点的next指针指向头结点：

**进队**：s->next=Q.rear->next;	Q.rear->next=s;

**出队**：s=Q.front;	Q.rear->next=s->next;	Q.front=Q.front->next;	free(s);			与普通单链表相比，循环单链表的出队操作需要额外改变队尾指针的next指针域，操作过于繁杂（针对不带头结点的循环单链表）

在一种特殊情况中，循环单链表可以很方便地实现**出队后原节点空间保留不释放**，**入队时利用原来的节点空间**，实现循环队列的链式存储。和循环队列的顺序存储一样，**牺牲一块存储空间**用来检测是否还有剩余空闲节点可以使用。队列带头结点，Q.rear指向队尾节点。

```c++
bool EnQueue(LinkQueue &Q,int x){
    if(Q.rear->next==Q.front) 
        此时队列满，无可用空闲节点，开辟一块新的节点空间用于存储;
    else
        将值赋给Q.rear指向的节点；Q.rear=Q.rear->next;return true;
}

bool DeQueue(LinkQueue &Q,int &x){
    if(Q.rear==Q.front)
        return false;
    else 
        取出队头结点的数据给x；front=front->next而不释放节点，留作备用；return true;
}
```

## 第五章  树

### 树的DFS与BFS遍历方法和应用

#### 1. DFS 深度优先搜索

与**递归**有关，可以用**栈**（非递归）实现

```c++
////////////////////////////////////////////
//递归实现
void preOrder(TreeNode * root){
    if(root==nullptr) return;		//递归出口
    visit(root);					//逻辑操作	访问在递归之前，为先序遍历 中序、后序遍历只用将visit()改变位置即可
    preOrder(root->left);			//递归入口
    preOrder(root->right);
}

//非递归实现
InitStack(S);						//stack<TreeNode*> S;
void preOrder2(TreeNode *root){
    TreeNode* cur=root;S.push(cur);
    while(cur||!S.empty()){
        if(cur){
            visit(cur);
            S.push(cur);			//中序遍历visit()移到else{}内部
            cur=cur->left;
            
        }
        else{
            cur=S.top();
            S.pop();
            cur=cur->left;
            
        }
    }
}
//////////////////////////////////////////////
//后序遍历的递归实现
InitStack(S);
void PostOrder2(TreeNode* root){
    TreeNode* cur=root,* ptr=nullptr;
    while(cur||!S.empty()){
        if(cur){
            S.push(cur);
            cur=cur->left;
        }
        else{
            cur=S.top();						//取栈顶元素，而不弹出
            //S.pop();
			
            if(cur->right&&cur->right!=ptr){
                cur=cur->right;
                
            }
            else{
                S.pop();
                visit(cur);
                ptr=cur;
                cur=nullptr;
            }
        }
    }
}
////////////////////////////////////////////////
//中序线索二叉树的结点
typedef struct ThreadNode{
    int val;
    ThreadNode *left,*right;
    int ltag,rtag;
}ThreadNode,*ThreadTree;
//中序线索二叉树的构造   使用DFS中序遍历递归方法
stack<TreeNode*> S;
void InThread(TreeNode* root,TreeNode* pre){
    if(!root) return;
    InThread(root->left,pre);
    if(root->left==nullptr){
        root->left=pre;
        root->ltag=1;
    }
    if(pre!=nullptr&&pre->right==nullptr){
        pre->right=root;
        pre->rtag=1;
    }
    pre=cur;
    InThread(root->right,pre);
}
```
 
## 第六章 图
### 6.1  图的基本存储结构

```c++
//领接矩阵法
#define MAXVERTEX 114514
typedef char VT;        //VertexType
typedef int ET;         //EdgeType
typedef struct{
    VT vertex[MAXVERTEX];
    ET Edge[MAXVERTEX][MAXVERTEX];
    int vernum;int edgenum;         //当前顶点个数、当前边数
}MGraph;


/////
//有向图的拓扑序列：将入度为零的节点按出度从小到大，先后排列起来;
//这样就能保证Eij存在且i<j，最终确定节点顺序（节点数组下标），从而使领接矩阵呈现出上（下）三角矩阵的特征
```

```c++
//领接表法          同一图可有多种AdjList表示方法
#define MaxVertex 114514
typedef char VT;        //VertexType
typedef int ET;         //EdgeType
typedef struct EdgeNode{
    ET edge;
    struct EdgeNode* next;
}EdgeNode;

typedef struct VertexNode{
    VT vertex;
    struct EdgeNode* first;
}VertexNode,AdjList[MaxVertex];     //事先确定好节点表大小，静态存储

typedef struct{
    AdjList Vertices；
    int vernum;int edgenum;
}AdjListGraph;                      //图自身结构只需存储节点即可


////////其一：十字链表法————有向图、三对角矩阵适用
typedef struct CEdgeNode{
    ET edge;
    unsigned int tailVertex,headVertex;     //直接存储节点数组下标（以此代表节点）
                                            //其中tail表示作为此边（弧）弧尾的节点，head表示作为此边弧头的节点
                                            //tail---->head
                                            //以上三者确定一条边
    
    CEdgeNode* hlink,* tlink;               //hlinl：以此弧弧头为弧头的下一个弧的指针；tlink：同弧尾的下一弧的指针
}CEdgeNode;

typedef struct CVertexNode{
    VT vertex;
    CEdgeNode* firstin,* firstout;
}CVertexNode,CrossLinkList[MaxVertex];

typedef struct{
    CrossLinkList vertices;
}CLLGraph;


////////其二：领接多重表————无向图适用
//将领接表的O(|V|+2|E|)空间复杂度缩小为O(|V|+|E|);
typedef struct MultiEdgeNode{
    int mark;           //标记该边是否被访问过
    ET edgeinfo;
    unsigned int ivex,jvex;         //与该边相接的节点在图中的位置（节点数组下标）
    MultiEdgeNode* ilink，* jlink;  //与ivex节点相接的下一边；与jvex相接的下一边
}MultiEdgeNode;

typedef struct MultiVertexNode{
    VT vexinfo;
    MultiEdgeNode* firstedge;
}MultiVertexNode,MultiAdjList[MaxVertex];

typedef struct{
    MultiAdjList vertices;
}MtAdjGraph;
```
### 6.2  图的遍历
#### 深度优先遍历 Depth-First-Traverse
```c++
void DFSTraverse(Graph G)
```


## 第九章  排序算法



### 快速排序

显然，QuickSort是需要**线性表的顺序存储结构 **支持的，因为需要**随机存区**

```c++

void QuickSort(int A[],int head,int tail){				//基础
    if(head<tail){
    int pivotPT=Partition(A,head,tail);
    QuickSort(A,head,pivotPT-1);
    QuickSort(A,pivotPT+1,tail);
        }
}

int Partition(int A[],int head,int tail){
    int pivot=A[head];
    while(head<tail){
        while(A[tail]>=pivot&&head<tail) tail--;
        A[head]=A[tail];
        while(A[head]<=pivot&&head<tail) head++;
        A[tail]=A[head];
    }
    A[head]=pivot;
    return head;
}

//快排的应用
//SPEC 1： 只需要找到顺序排列的第K个元素下标  				特征：数列比较大小，有n种情况，每次交换元素都要重新比较
int Partition1(int A[],int low,int high){
    int pivot=A[low];int low0,high0;
    while(low<high){								//循环主体
        low0=low;high0=high;
        while(low<high&&A[high]>=pivot) high--;
        A[low]=A[high];
        while(low<high&&A[low]<=pivot) low++;
        A[high]=A[low];
    }
    if(low==k-1) return A[low];						//第k个元素，下标为k-1  返回数值
    else if(low<k-1) Partition(A,low+1,high0);
    else if(low>k-1) Partition(A,low0,low-1);
}
////
int Partixion1(int A[],int low,int high){			//快排的另一种写法  可以用来快速得到X元素在乱序队列中的位置
    int pivot=A[low];
    int i=low;
    for(int j=low+1;j<=high;j++){					//循环体
        if(A[j]<pivot) swap(A[++i],A[j]);
        swap(A[i],A[low]);
        return i;									//最终的位置
    }
}

//SPEC 2：  只有两种情况需要排序  如奇数偶数排列，奇数在偶数之前
int Partition2(int A[],int low,int high){
    while(low<high){	
        while(low<high&&A[low]%2==1) low++;			//从前往后找到第一个偶数时跳出循环
        while(low<high&&A[high]%2==0) high--;		//从后往前找到一个奇数时跳出循环
        if(low<high){
            swap(A[low],A[high]);
            low++;high--;
        }
    }
}

//SPEC 3：  有三种情况  左中右顺序排序
int Partition3(int A[],int low,int high){			//使用三个工作指针记录排序的位置，向前或者向后交换。
    int i=low,j=low,k=high;
    while(j<=k){
        switch(A[j]){
            case 1:swap(A[j],A[i]);i++;j++;break;
            case 2:j++;break;
            case 3:swap(A[k],A[i]);k--;break;
        }
    }
}
```

### 递归

```c++
//递归判断回文数
#include<iostream>
#include<string>
using namespace std;
void Reve(string S,int num,int len) {
	if (num >= len / 2) {
		cout << "Yes" << endl;
		return;
	}
	if (S[num] != S[len - 1 - num]) {
		cout << "No" << endl;
		return;
	}
	Reve(S, num + 1, len);
}
int main() {
	string A;
	getline(cin, A);
	int a = A.length();
	Reve(A, 0, a);
	system("Pause");
	return 0;
}



//递归输出数组最大值
#include<iostream>
#include<string>
using namespace std;
int findMax( int *a,int num,int len) {
	if (num == len - 1) return a[num];
	else {
		int x = a[num]; int y = findMax(a, num + 1, len);
		if (x > y) return x;
		else return y;
	}
}
int main() {
	int num;
	cin >> num;
	int *A = new int[num];
	for (int i = 0; i < num; i++) {
		cin >> A[i];
	}
	cout << findMax(A, 0, num );
	system("Pause");
	return 0;
}



#include<iostream>
#include<iomanip>
#include<math.h>
using namespace std;
int a3, a2, a1, a0;
double x;
double f(double x) {
	return a3*pow(x,3) + a2*pow(x,2) + a1*x + a0;
}
void Gen(double a, double b,double &x) {
	double mid = (a + b) / 2; double Up = f(b), Down = f(a);
	double Mid = f(mid);
    if(b-a<0.001) {
        x=mid;
        return;
    }
	if (Mid == 0) {
		x=mid;
		return;
	}
	else if (Up*Mid > 0) Gen(a, mid,x);
	else if (Down*Mid > 0) Gen(mid, b,x);
}

int main() {
	cin >> a3 >> a2 >> a1 >> a0;
	double down, upper;
	cin >> down >> upper;
    if(f(down)==0) {x=down;}
    else if(f(upper)==0) {x=upper;}
    else if(f(down)*f(upper)<0){
        Gen(down, upper,x);
    }
    cout<<setiosflags(ios::fixed)<<setprecision(2)<<x<<endl;
	return 0;
}
```

### 双向冒泡排序

```c++
int * Twoway_BubbleSort(int A[],int len){
    int st=0,ed=len-1;
    int i=0,j=0,flag=1,tmp;
    while(st<ed&&flag){
        flag=0;
        for(i=ed;i>st;i--){
            if(A[i-1]>A[i]){
                tmp=A[i-1];A[i-1]=A[i];A[i]=tmp;
                flag=1;
            }
		}
        st++;
        for(j=st;j<ed;j++){
            if(A[j+1]<A[j]){
                tmp=A[j+1];A[j+1]=A[j];A[j]=tmp;
                flag=1;
            }
        }
        ed--;
    }
    return A;
}
```

